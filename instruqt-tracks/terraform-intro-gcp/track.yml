slug: terraform-intro-gcp
id: wykyne6vqrul
type: track
title: Intro to Terraform on GCP
teaser: |
  Provision the HashiCat application on GCP using Terraform.
description: |-
  This track will introduce you to Terraform on Google Cloud Platform (GCP). We'll learn Terraform setup, basic commands, and gradually build an entire application stack. When you're finished you'll be able to view the HashiCat application in your web browser.

  Kittens as a Service!
icon: https://storage.googleapis.com/instruqt-hashicorp-tracks/logo/terraform.png
tags:
- terraform
- gcp
- basics
owner: hashicorp
developers:
- assareh@hashicorp.com
- roger@hashicorp.com
private: true
published: true
show_timer: true
challenges:
- slug: setup-our-environment
  id: iwy0y3xnwoug
  type: challenge
  title: "\U0001F3E1 Moving in - Set Up Your Workspace"
  teaser: |
    Configure your code editor with the Terraform extension and open a workspace.
  notes:
  - type: text
    contents: |
      Setting up your environment...
      Keep an eye on the bottom right corner to know when you can get started.
  - type: text
    contents: The Terraform command line tool is available for MacOS, FreeBSD, OpenBSD,
      Windows, Solaris and Linux.
  - type: text
    contents: The Terraform language is designed to be both human and machine-readable.
  - type: text
    contents: Most modern text editors support Terraform syntax highlighting.
  assignment: |-
    Open the Code Editor tab on the left. First get familiar with the menus. This is running the Visual Studio Code editor. You can also use the simpler "Text Editor" tab if you prefer.

    If you do use the VS Code Editor, please perform the following steps:

    Notice the menu bar with File, Edit, and other menus at the top of the VS Code Editor. You can find all the menus on this menu bar.

    You should see some files in the explorer bar on the left side menu. These are terraform config files for the hashicat application. Open file called "main.tf.

    Next you should install the HashiCorp Terraform extension to enable syntax highlighting in your code. Click on the extensions icon - it looks like four small boxes with one slightly out of position.

    Search for **HashiCorp** and select the "HashiCorp Terraform 2.x.y" extension. Click the blue **Install** or blue **Install in Remote** button to install the extension. Then click the icon with two pages under the File menu so you can see your Terraform files again.

    We have enabled auto-save in your Code Editor, so any changes you make will be saved as you type. You don't have to worry about saving files manually.

    We recommend executing all commands on the "Shell" tab. But you can also open and use a terminal window at the bottom of the Visual Code Editor by using the Terminal > New Terminal menu or the **<ctrl>-`** shortcut.

    If you do use the VS Code terminal, you can toggle its size up and down with the `^` and inverted `^` buttons above it. You can get rid of it with the garbage can and `x` icons.

    Congratulations, you are ready to start working with Terraform on GCP. We'll use the hashicat-gcp example app in the rest of the challenges as you learn new Terraform skills.

    Click the **Check** button to continue.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: hello-terraform
  id: ywoomemahyjg
  type: challenge
  title: "\U0001F44B Getting to Know Terraform"
  teaser: |
    Learn Terraform basics and command line syntax.
  notes:
  - type: text
    contents: |-
      Terraform open source is a command line application that you can download and run from your laptop or virtual workstation.

      It is written in Go and runs on macOS, Linux or Windows. You can always download the latest version of Terraform from https://www.terraform.io/downloads.html
  - type: text
    contents: |-
      Installing Terraform on your laptop or workstation is easy. You simply download the zip file, unpack it, and place it somewhere in your PATH.

      Check out this tutorial for step-by-step instructions:

      https://learn.hashicorp.com/terraform/getting-started/install.html

      We've pre-installed Terraform in your Instruqt lab environment for you.
  assignment: |-
    Let's start with some basic Terraform commands.
    Run the following commands in the "Shell" tab or in a terminal in the VS Code editor.

    Check the version of Terraform running on your machine:
    ```
    terraform version
    ```
    You can always get help if you're curious about command syntax:
    ```
    terraform help
    ```
    Terraform runs on Windows, OSX, or Linux. You can install it on your laptop or on a cloud based workstation.

    Today we'll be using the preconfigured Terraform workstation on the left for all our lab exercises.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: gcp-credentials
  id: 0jfdfianuvso
  type: challenge
  title: "\U0001F510 Connecting Terraform to GCP"
  teaser: |
    Connecting to GCP with Google Credentials.
  notes:
  - type: text
    contents: Did you know HCL stands for "HashiCorp Configuration Language"?
  assignment: |-
    In order to authenticate to GCP and build resources, Terraform requires you to provide a set of credentials, backed by an appropriate IAM policy.

    For this training environment, we have prepared some temporary GCP credentials and stored them as an environment variable. Terraform will automatically read and use the environment variables that are configured in your shell environment.

    Run the following command in the "Shell" tab or in a terminal in the VS Code editor to see your temporary credentials:

    ```
    echo $GOOGLE_CREDENTIALS | jq
    ```

    *Do not ever store your credentials in source code files*, as they can be accidentally exposed or copied to a public repository.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: terraform-code
  id: ep819mvquvfz
  type: challenge
  title: "\U0001F468‍\U0001F4BB What does Terraform code look like?"
  teaser: |
    The Terraform DSL (Domain Specific Language) is a declarative language that lets you build almost any type of infrastructure.
  notes:
  - type: text
    contents: |-
      Terraform will read anything in the current directory that ends in `*.tf` or `*.tfvars`.

      By convention most Terraform workspaces will contain `main.tf`, `variables.tf`, and `outputs.tf` files.

      You can also group your Terraform code into files by purpose. For example, you might place all your load balancer configuration code into a file called `load_balancer.tf`.
  assignment: |-
    We've downloaded some Terraform code onto your workstation. Run the following command to see the Terraform code files:
      ```
      ls *.tf
      ```
      <br>
      The same files are visible in the file explorer pane on the left. Terraform files are marked with the purple T icon.

      Terraform code always ends with a `.tf` extension. You can have as many Terraform files as you want, but these three are commonly created first:

      **main.tf** - Where most of your Terraform code is stored. This is the part that does the building of resources.<br>
      **variables.tf** - Use this file to define which variables will be available to your users.<br>
      **outputs.tf** - This file contains outputs that will be shown at the end of a successful Terraform run.

      Files that end in anything other than `*.tf` or `*.tfvars` are ignored by Terraform.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: terraform-init-provider
  id: xqjwxzyqgovz
  type: challenge
  title: "\U0001F3E1 Terraform Init - Install the Providers"
  teaser: |
    Terraform needs a provider to talk to cloud APIs. The provider is the bridge that connects Terraform core to your infrastructure providers.
  notes:
  - type: text
    contents: |-
      The Terraform core program isn't very useful by itself. Terraform needs the help of a *provider* to be able to talk to cloud APIs. Terraform has hundreds of different providers. You can browse the provider list here:

      https://registry.terraform.io/browse/providers

      Today we'll be using a few different providers, but the main one is the *gcp* provider.
  assignment: |-
    We have downloaded some Terraform code for the HashiCat application. We'll be using this source code for the rest of the track.

    Before we can do anything with Terraform we need to initialize our workspace. Run the following command in your "Shell" tab:
    ```
    terraform init
    ```

    The `terraform init` command scans your Terraform code, identifies any providers that are needed, and downloads them.

    Run the following command to verify that the google provider was installed under the ".terraform" directory::

    ```
    ls .terraform/providers/registry.terraform.io/hashicorp
    ```
    <br>
    This hidden directory is where all modules and plugins are stored.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: provider-quiz
  id: akjg23kjagyb
  type: quiz
  title: "\U0001F4DD Quiz 1 - Providers and Modules"
  teaser: |
    A quiz about Terraform init
  notes:
  - type: text
    contents: |
      It's quiz time!
  assignment: |
    Where does Terraform store its modules and providers?
  answers:
  - In the /tmp directory
  - In the user's home directory
  - In the .terraform directory
  - None of the above
  solution:
  - 2
  difficulty: basic
  timelimit: 1000
- slug: terraform-validate
  id: 5lw6oh7gkgma
  type: challenge
  title: "\U0001F469‍⚖️ Terraform Validate - Test Your Code"
  teaser: |
    Terraform has a built in validation tester. This is useful to see whether your Terraform code is valid and parses correctly.
  notes:
  - type: text
    contents: Terraform has a built-in syntax checker. You can run it with the `terraform
      validate` command.
  assignment: |-
    Terraform comes with a built-in subcommand called *validate*. This is useful when you want to do a quick syntax check of your code to make sure it parses correctly.

    Click on the File Explorer icon on the left. It looks like a stack of papers.

    Edit the main.tf file and remove the double quotes between `google_compute_network` and `hashicat` on line 15 of the file, keeping the space that was between them.

    Validate your code:

    ```
    terraform validate
    ```

    Now put the double quotes back in line 15 and run the `validate` command again. This time you should pass the validation test.

    `terraform validate` is most often used in automated CI/CD test pipelines. It allows you to quickly catch errors in your code before any other steps are taken.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: terraform-plan
  id: qynplfqy792d
  type: challenge
  title: "\U0001F914 Terraform Plan - Dry Run Mode"
  teaser: |
    Terraform has a dry run mode where you can preview what will be built without actually creating any resources. In this challenge we'll run `terraform plan` and view the output.
  notes:
  - type: text
    contents: |-
      `terraform plan` allows you to preview any changes to your environment in a safe way.

      This can help you identify any unexpected changes before you deploy them, not after they are already built.
  assignment: |-
    Run the `terraform plan` command:

    ```
    terraform plan
    ```

    When you run this command Terraform will prompt you to enter the `prefix` variable.

    Enter a short string of lower-case letters and/or numbers. We recommend that you use your first and last name.

    The prefix will become part of the name for our VPC network, subnet, and compute instance, as well as appear in the HashiCat application.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: terraform-variables
  id: ua2eq9kzrnc5
  type: challenge
  title: "\U0001F39B️ Working with Terraform Variables"
  teaser: |
    Terraform variables allow you to customize your infrastructure without editing any code. You can use the same Terraform code to deploy dev, staging and production but with different variables.
  notes:
  - type: text
    contents: The `terraform.tfvars` file is a convenient place for users to configure
      their variables.
  assignment: |-
    In Terraform all variables must be declared (with or without an optional default value) before you can use them. Variables are usually declared in the "variables.tf" file although they can also be declared in other "*.tf" files. Their values can be set in the "terraform.tfvars" file and in other ways which we'll explore later.

    Open the "terraform.tfvars" file and set your `prefix` variable by deleting the `# ` at the beginning of the line and replacing "yourname" with your own name (first and last with or without a hyphen between them and all lower case).

    Now run `terraform plan` again. This time you won't have to enter your prefix manually.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: terraform-add-a-variable
  id: xjx3ttlhkile
  type: challenge
  title: "\U0001F5FC Change Your Location"
  teaser: |
    Terraform is flexible enough to deploy infrastructure anywhere in the world. You can easily provision your applications in different geographical regions by simply changing a single variable.
  notes:
  - type: text
    contents: |-
      You can override any variable defined in the "variables.tf" file by setting it in your personal `terraform.tfvars` file.

      In this challenge, you will pick the location where your GCP resources should be deployed.
  assignment: |-
    In the previous challenge we set our `prefix` variable in the "terraform.tfvars" file. Let's set two more variables that will determine the location where your GCP infrastructure will be deployed.

    First run another plan so you'll be able to compare what happens after you change the location.

    ```
    terraform plan
    ```

    Choose a GCP region near you but different from the default one which is "us-central1". Add `region` and `zone` variables to your "terraform.tfvars" file, setting them to your desired region and one of its zones.

    See this [page](https://cloud.google.com/compute/docs/regions-zones) for a list of regions and zones. For regions, strip off the `-a`, `-b`, or `-c` from the zones listed on that page.

    Choosing a region close to you can help improve speed and performance.

    Once you've set your `region` and `zone` variables, try running `terraform plan` again. What's different this time?

    Remember that you can set values for any variable declared in your "variables.tf" file in the "terraform.tfvars" file.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: variables-quiz
  id: f52k9olell3f
  type: quiz
  title: "\U0001F4DD Quiz 2 - Variables"
  teaser: |
    A quiz about Terraform variables
  notes:
  - type: text
    contents: |
      Another quiz, get ready!
  assignment: |
    Where are terraform variables *declared*?
  answers:
  - On the command line
  - As environment variables
  - In the variables.tf file
  - In the terraform.tfvars file
  solution:
  - 2
  difficulty: basic
  timelimit: 1000
- slug: tf-graph
  id: 1yron0ldujiy
  type: challenge
  title: "\U0001F4C8 Terraform Graph"
  teaser: |
    Terraform creates a graph of all the infrastructure defined in your code.
  notes:
  - type: text
    contents: Terraform Graph can provide a visual representation of all your infrastructure.
      This is handy for finding dependency issues or resources that will be affected
      by a change.
  assignment: |-
    Try running the `terraform graph` command:

    ```
    terraform graph
    ```

    This generates code that can be used to create a visual map of your infrastructure. The graph data is in [DOT graph description language format](https://en.wikipedia.org/wiki/DOT_(graph_description_language)). There are several graphing tools you can use to visualize this data, including the free Blast Radius tool. You can learn more about Blast Radius here:

    https://28mm.github.io/blast-radius-docs/

    Start up a Blast Radius server with the following command:

    ```
    blast-radius --serve .
    ```

    Now switch to the **Terraform Graph** tab to view the infrastructure graph. If the web page is blank, you may need to click the refresh icon in Instruqt, which is directly to the right of the **Terraform Graph** tab and looks like a circular arrow.

    Explore the Terraform graph for your infrastructure. Dependencies are automatically mapped out for you. This graph was generated using the free Blast Radius tool.

    **NOTE:** Due to a known bug you may not be able to drag and zoom the graph. The main point of this exercise is to see how terraform maps out complex infrastructure. So don't worry if your graph doesn't show color.

    Terraform uses this graph to determine which resources can be built in parallel for maximum efficiency.
  tabs:
  - title: Command Line
    type: terminal
    hostname: workstation
  - title: Terraform Graph
    type: service
    hostname: workstation
    port: 5000
  difficulty: basic
  timelimit: 1000
- slug: tf-apply
  id: 7e7wxtavuwfl
  type: challenge
  title: "\U0001F468‍\U0001F4BB Terraform Plan and Apply"
  teaser: |
    The `terraform plan` command can be run anytime to get a preview of changes that Terraform might make. When you run Terraform apply these changes are implemented, and Terraform builds, updates, or destroys resources.
  notes:
  - type: text
    contents: |-
      By default, the `terraform apply` command runs a Terraform plan to show you what changes it wants to make.

      Terraform maps out all the changes it needs to make before applying them.
  assignment: |-
    Now that we've configured our required prefix variable we can apply our Terraform configuration.

    Run the `terraform plan` command first to see what will happen:

    ```
    terraform plan
    ```

    Confirm the proper prefix is displayed in the plan output. Look for **# google_compute_network.hashicat** and find the output next to **+ name**.

    Then run `terraform apply` and watch your resources being built.

    ```
    terraform apply
    ```

    You'll need to enter **yes** when Terraform prompts you with the "Do you want to perform these actions?" question.

    Right now our code only defines a VPC network. We'll be building upon this starting point in the next challenge.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: tf-plan-again
  id: emge3jei9mhg
  type: challenge
  title: "\U0001F469‍\U0001F4BB Test and Repair"
  teaser: |
    Terraform is idempotent. Each resource in your code will be examined, and if it already exists Terraform will leave it alone.
  notes:
  - type: text
    contents: |-
      Terraform is an *idempotent* application.

      Idempotence is the property of certain operations in mathematics and computer science whereby they can be applied multiple times without changing the result beyond the initial application.

      https://en.wikipedia.org/wiki/Idempotence
  assignment: |-
    Try running `terraform plan` again and see what happens:

    ```
    terraform plan
    ```
    <br>
    Since your VPC network has already been built, Terraform will report that there are no changes required.

    This is normal and expected.

    Now try running another apply:

    ```
    terraform apply
    ```
    <br>
    Terraform checks each resource to ensure it is in the proper state. It will not re-create your VPC network if it is already provisioned correctly.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: change-prefix
  id: adutewsygtuk
  type: challenge
  title: "\U0001F6EB Change Your Prefix"
  teaser: |
    When your Terraform code changes, your infrastructure will be modified to match the updated code. Terraform is a declarative language.
  notes:
  - type: text
    contents: |-
      Terraform can create, destroy, update in place, or destroy and re-create your infrastructure. Some types of resources can be updated without deleting them. Major changes usually require a teardown and rebuild.

      Terraform always tries to match the current infrastructure to what has been defined in your code.
  assignment: |-
    Edit the `terraform.tfvars` file to change your prefix. You could simply add a number to the end if you like. Or change it to something entirely new.

    Save the `terraform.tfvars` file and run your apply command again.

    ```
    terraform apply
    ```

    Type "yes" when prompted.

    Observe the output. What happened?
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: add-virtual-network
  id: yczv2x5h1oy1
  type: challenge
  title: "\U0001F5A7 Add a Virtual Network"
  teaser: |
    Terraform resources are like building blocks. You can continue adding more blocks until your infrastructure reaches the desired state.
  notes:
  - type: text
    contents: Terraform code can be built incrementally, one or two resources at a
      time.
  assignment: |-
    Open the **main.tf** file again and uncomment the next resource block in the file. The type of resource is **google_compute_subnetwork** and it is named **hashicat**.

    Uncomment the code by removing the `#` characters from the beginning of each line.

    Now run `terraform apply` again. Observe the results.

    Look at the **network** parameter inside the google_compute_subnetwork resource. See how it points back at the first resource in the file? The subnet resource inherits settings from the VPC network.

    Terraform can map out the complex web of dependencies between hundreds of interconnected resources.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: complete-the-build
  id: ghjx8usnjyr9
  type: challenge
  title: "\U0001F3D7️ Complete the Build"
  teaser: |
    Terraform code can stand up everything from a GCP project, to virtual networks, to VMs and containers.
  notes:
  - type: text
    contents: The `-auto-approve` flag can be used to override the "Are you sure?"
      questions that appear before an apply or destroy. Use with caution!
  assignment: |-
    We've uncommented the rest of the Terraform code in the **main.tf** file for you. Run a `terraform plan` to see what will be built:

    ```
    terraform plan
    ```
    <br>
    Now run an apply to build the HashiCat application:

    ```
    terraform apply -auto-approve
    ```
    <br>
    It can take up to five minutes for the application to finish deploying. You will know it is complete when you see the Terraform output with your application URL at the end of the run.

    If the application won't load just run `terraform apply` again. This will attempt to reinstall the webserver and start your application if it's not running.

    Open your web application in a new browser tab. You'll need to copy and paste the URL into your address bar.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: tf-graph-again
  id: spkrgorlkh27
  type: challenge
  title: "\U0001F4C8 Terraform Graph"
  teaser: |
    Revisit graph to see what has changed.
  notes:
  - type: text
    contents: Let's revisit our graph to see what has changed.
  assignment: |-
    Start up a Blast Radius server with the following command:

    ```
    blast-radius --serve .
    ```

    Now switch to the **Terraform Graph** tab to view the infrastructure graph. If the web page is blank, you may need to click the refresh icon in Instruqt, which is directly to the right of the **Terraform Graph** tab and looks like a circular arrow.

    Explore the Terraform graph for your infrastructure. Dependencies are automatically mapped out for you. This graph was generated using the free Blast Radius tool.

    **NOTE:** Due to a known bug you may not be able to drag and zoom the graph. The main point of this exercise is to see how terraform maps out complex infrastructure. So don't worry if your graph doesn't show color.

    Terraform uses this graph to determine which resources can be built in parallel for maximum efficiency.
  tabs:
  - title: Command Line
    type: terminal
    hostname: workstation
  - title: Terraform Graph
    type: service
    hostname: workstation
    port: 5000
  difficulty: basic
  timelimit: 1000
- slug: terraform-apply-quiz
  id: uazp9mdggs3r
  type: quiz
  title: "\U0001F4DD Quiz 3 - Terraform Apply"
  teaser: |
    What happens when you run `terraform apply` without a plan file?
  notes:
  - type: text
    contents: |
      It's quiz time!
  assignment: |
    What happens when you run `terraform apply` without specifying a plan file?
  answers:
  - Terraform runs without any plan
  - Terraform reads the previous plan and then applies it
  - Terraform runs a new plan right before the apply
  - None of the above
  solution:
  - 2
  difficulty: basic
  timelimit: 1000
- slug: use-a-provisioner
  id: xgqv8izcag5g
  type: challenge
  title: "\U0001F6E0️ Use a Provisioner"
  teaser: |
    Terraform works great with many different provisioning tools including Chef, Puppet, Ansible, Bash, and Powershell.
  notes:
  - type: text
    contents: Terraform provisioners run once at creation time. They do not run on
      subsequent applies, except in special circumstances. (Like this training lab...)
  - type: text
    contents: We've made some special adjustments to force the provisioner run every
      time you type terraform apply. This is so you can practice playing with provisioners
      without destroying and recreating your virtual machine every time you make a
      change.
  - type: text
    contents: |-
      ```
      ______________________
      < Cows love Terraform! >
       ----------------------
               \   ^__^
                \  (oo)\_______
                   (__)\       )\/\
                       ||----w |
                       ||     ||
      =============================
      ```
  assignment: |-
    Open the `main.tf` file in the Code Editor. Scroll down until you find the `remote-exec` provisioner block, or search the file and find it with CTRL-F.

    Add the following two lines at the end of the inline list of commands:

    ```
    "sudo apt -y install cowsay",
    "cowsay Mooooooooooo!",
    ```

    After copying them into your buffer, it will be easier to paste them if you hide the assignment by clicking the icon that looks like a picture frame next to the circular refresh icon. Click it again to redisplay the assignment.

    This might be a good time to use the `terraform fmt` command to line up the commands nicely.

    Now run another `terraform apply -auto-approve` to apply your changes:

    ```
    terraform apply -auto-approve
    ```
    <br>
    Scroll back through the log output. You should see an ASCII art cow saying "Moooooooo!"
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: add-an-output
  id: klojaiqiwydp
  type: challenge
  title: "\U0001F5A8️ Add an Output"
  teaser: |
    Outputs are used to convey useful information such as IP addresses, application URLs or other useful data.
  notes:
  - type: text
    contents: You can mix plain text along with Terraform data in your outputs. Outputs
      can be used to convey useful information to your users at the end of a run.
  - type: text
    contents: The `terraform refresh` command will sync your state file with what
      exists in your infrastructure. A refresh command will not change your infrastructure.
  - type: text
    contents: The `terraform output` command can be run any time you want to see your
      Terraform outputs again. Run `terraform output <output_name>` to view a single
      output.
  assignment: |-
    Open the **outputs.tf** file in the Code Editor. Note the catapp_url output in the file.

    Add a second output for the `network_ip` of your web server. It's going to look a lot like the first output but will instead output the internal IP address instead of the external one.

    Name your output `catapp_ip`.

    You may refer to the docs page to see what types of outputs are valid:

    [Terraform GCP Docs - Click Here](https://www.terraform.io/docs/providers/google/r/compute_instance.html#attributes-reference)
    [Terraform Outputs Docs - Click Here](https://www.terraform.io/docs/configuration/outputs.html)

    Run the Terraform refresh command to view your new output:

    ```
    terraform refresh
    ```

    You can run the Terraform output command to view all your outputs:

    ```
    terraform output
    ```
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: fun-with-variables
  id: vw0r0cfqjjox
  type: challenge
  title: "\U0001F436 Fun With Variables"
  teaser: |
    Variables give the consumers of your Terraform code an easy way to customize their infrastructure.
  notes:
  - type: text
    contents: |-
      Terraform variables have five levels of precedence. 1=highest 5=lowest:

      1. Command line flag - run as a command line switch
      1. Configuration file - set in your terraform.tfvars file
      1. Environment variable - part of your shell environment
      1. Default Config - default value in variables.tf
      1. User manual entry - if not specified, prompt the user for entry
  - type: text
    contents: |-
      Here are some other fun placeholder sites you can try with the **placeholder** variable:

      placedog.net<br>
      placebear.com<br>
      www.fillmurray.com<br>
      www.placecage.com<br>
      placebeard.it<br>
      loremflickr.com<br>
      baconmockup.com<br>
      placeimg.com<br>
  assignment: |-
    There are several ways to configure Terraform variables. So far we've been using the `terraform.tfvars` file to set our variables. Try re-deploying your application with different **height** and **width** variables on the command line. Reload the webapp after each apply to observe any changes.

    ```
    terraform apply -auto-approve -var height=600 -var width=800
    ```
    <br>
    Next try setting an environment variable that Terraform can read. Run this command to set the placeholder variable:

    ```
    export TF_VAR_placeholder=placedog.net
    ```

    Run another `terraform apply -auto-approve` command:
    ```
    terraform apply -auto-approve
    ```

    Now try it again with the same variable set differently on the command line:
    ```
    terraform apply -auto-approve -var placeholder=placebear.com
    ```

    Which variable took precedence? Why?

    See this [doc](https://www.terraform.io/docs/configuration/variables.html#variable-definition-precedence) if you're unsure.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: terraform-variables-quiz
  id: 63v5yqxkudwy
  type: quiz
  title: "\U0001F4DD Quiz 4 - Terraform Variables"
  teaser: |
    How do Terraform variables get set or overridden?
  notes:
  - type: text
    contents: |
      Get ready for another quiz...
  assignment: |
    You have the same variable set in a *.tfvars file and as an environment variable. Which one takes precedence?
  answers:
  - The environment variable
  - The tfvars config file
  solution:
  - 1
  difficulty: basic
  timelimit: 1000
- slug: terraform-cloud-setup
  id: luiv2wpftyhp
  type: challenge
  title: ☁️ Terraform Cloud Setup
  teaser: |
    Terraform Cloud offers unlimited free Terraform state storage for users. Safeguard your state files by storing them remotely in Terraform Cloud.
  notes:
  - type: text
    contents: Terraform Cloud remote state storage is free for all users.
  assignment: |-
    During this challenge and the next one, you'll use the remote state feature of Terraform Cloud to store your state file in the cloud. In order to do this you'll need a Terraform Cloud account. Click on the URL below and sign up for a free account if you don't have one already:

    https://app.terraform.io/signup/account

    If you already have an account you can simply sign in with your existing credentials.

    Once you're signed into Terraform Cloud create a new organization called YOURNAME-training. Replace YOURNAME with your own name or other text.

    Next you'll be prompted to create a workspace. You can skip the VCS integration step by clicking the "CLI-driven workflow" panel. Name your workspace **hashicat-gcp**.

    **Note:** If you already have a **hashicat-gcp** workspace, please delete the workspace by selecting the **Settings >> Destruction and Deletion** menu, clicking the "Delete from Terraform Cloud" button, typing "hashicat-gcp" to confirm, and then clicking the "Delete workspace" button. Then re-create it as above. Doing this avoids possible problems with mis-matched state versions when executing local runs after having executed remote runs. This could happen if you played the [Terraform Cloud with GCP](https://play.instruqt.com/hashicorp/tracks/terraform-cloud-gcp) track and then played this track.

    Run `terraform version` on the "Shell" tab and then set the **Terraform Version** to match on the workspace's **Settings >> General** settings page.

    Also, change the **Execution Mode** to **Local**.

    Be sure to save your settings by clicking the "Save settings" button at the bottom of the page! This will allow us to run Terraform commands from our workstation with local variables, which we'll do in the next challenge.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: configure-remote-state
  id: oyk8ahcyfqkd
  type: challenge
  title: "\U0001F39B️ Configure Remote State"
  teaser: |
    The terraform command line tool can store its state in Terraform Cloud. All that is required is a user token.
  notes:
  - type: text
    contents: |-
      With *local* execution mode the Terraform commands and variables all remain
      on your workstation.

      With *remote* execution mode Terraform runs in a Terraform Cloud
      container environment. All variables must be configured in the cloud environment with this method.
  assignment: |-
    During this challenge we'll configure Terraform Cloud as a remote state backend, and then migrate our existing state file to Terraform Cloud.

    Edit the `remote_backend.tf` file and replace the YOURORGANIZATION and YOURWORKSPACE placeholders with your org name and workspace name.

    Let's generate a new **user token** for use on your workstation. Visit the User Settings > Tokens page in Terraform Cloud:

    https://app.terraform.io/app/settings/tokens

    Click on the **Create an API token** button. You can name the token whatever you like. Copy the entire token using your mouse or the small copy-paste icon.

    Back in the Instruqt track, you need to add your API token to a file called "credentials.tfrc.json". You can do this in two different ways:

    The easier way is to select the "Credentials File" tab and open the `/root/.terraform.d/credentials.tfrc.json` file directly.

    But if you prefer to use the VS Code Editor, you can use the File > Open menu, click on "..", select ".terraform.d", and then select the "credentials.tfrc.json" file.

    In either case, replace the part that says YOURTOKEN with what you copied from Terraform Cloud. If you use the "Credentials File" tab,  sure to save the file.

    Your token is now safely stored in the `/root/.terraform.d/credentials.tfrc.json` file.

    Now run `terraform init` to migrate your state to Terraform Cloud.

    ```
    terraform init
    ```

    Type "yes" when it prompts you to migrate your state into Terraform Cloud.

    Your state is now safely stored in Terraform Cloud.

    Run a `terraform apply -auto-approve` and watch your state file evolve with each change. You can browse through previous state files with the Terraform Cloud UI.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Credentials File
    type: code
    hostname: workstation
    path: /root/.terraform.d/credentials.tfrc.json
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
- slug: terraform-destroy
  id: vr2l7n2itbvy
  type: challenge
  title: "\U0001F525 Terraform Destroy"
  teaser: |
    Terraform can build infrastructure and also destroy it when you are done using it. This helps control costs and reduce infrastructure sprawl.
  notes:
  - type: text
    contents: |-
      Terraform can destroy infrastructure as easily as it can build it.

      Use `terraform destroy` with caution.
  assignment: |-
    Run the following command to destroy your infrastructure:

    ```
    terraform destroy
    ```
    <br>
    You'll need to type "yes" when prompted to destroy your infrastructure. This is a safety feature to help prevent accidental deletion of important resources.

    Wait until the destroy action has completely finished before clicking on the **Check** button.
  tabs:
  - title: Code Editor
    type: service
    hostname: workstation
    port: 8443
  - title: Text Editor
    type: code
    hostname: workstation
    path: /root/hashicat-gcp
  - title: Shell
    type: terminal
    hostname: workstation
  difficulty: basic
  timelimit: 1000
checksum: "15446258363644981857"
